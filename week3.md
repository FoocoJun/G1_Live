## 3주차 (16강/86강 수강률 18.60% : 122,760원)
### 요약
- 데이터 연동
- 컨트롤러 Hero -> HeroCamp로 이관
- 캐릭터 콜라이더 적용
- 랜더러 y축 적용
- AI 추가작업

### 1. 데이터 연동
- csv파일 추가 다운로드
- 기존 하드코딩 부분 Data Manager로 부터 불러온 값으로 수정
### 2. 컨트롤러 Hero -> HeroCamp로 이관
- 기존 조이스틱의 움직임 방향과 직접 연결되어 있던 Hero 로직 제거
- 그룹 이동 구현을 위한 중심점과 방향을 관리하는 HeroCamp 생성
- 중심점과 회전하는 Pivot 위의 Destination으로 구성
- 조이스틱의 움직임에 따라 Destination이 위치하도록 로직 확장
- Hero는 추가된 AI에 의해 Destination을 향하도록 수정
### 3. HeroCamp 콜라이더 적용
- 장애물에 부딪혀야 하고 몬스터와 히어로랑은 겹칠 수 있어야 함
- 어려운 부분은 아닌데 비트 플래그 방식이 흥미로워 목차에 채택
```c#
  Collider.includeLayers = (1 << (int)ELayer.Obstacle);
  Collider.excludeLayers = (1 << (int)ELayer.Monster) | (1 << (int)ELayer.Hero);
```
- 1을 8비트 이진수로 표현하면 0000 0001이다.
- Enum은 각 정수를 가진다. (이때, Monster 7, Hero 6)
- a << b 연산자는 이진수 a를 왼쪽으로 b칸 민다.
- (1 << (int)ELayer.Monster)는 0100 0000이 된다.
- (1 << (int)ELayer.Hero)는 0010 0000이 된다.
- |는 or 연산자로 두 비트를 합친다.
- 즉 0110 0000이 된다.
- 응용하면 한 바이트에 8개의 상태를 담을 수 있게 된다.
- 어라.. 회사에서 YYYNYNNY하던게... 에후..
### 4. 랜더러 y축 적용
- 2D는 앞뒤 구분이 쉽지 않다.
- Renderer에서 y축으로 소팅을 해줄 수 있다.
- y축이 높으면 먼저 랜더링 함으로서 앞 뒤를 구분 할 수 있게 된다.
- 세상 참 좋다.

![image](https://github.com/FoocoJun/G1_Live/assets/85068289/0fb1c0fc-4a16-41cb-af6f-0be5376a6c52)
### 5. AI 추가작업
- 여기서부터 강의 코드를 따라치지 않게 되었다.
- 강의의 코드가 마음에 딱 맞지 않기 때문도 있다.
- 너무 벌어져서 디버깅 안될 정도가 되지는 말자..
  - 예를 들어 가장 가까운 거리의 몬스터를 찾는 로직이 있었다.
  - forEach문을 다 도는게 건강하긴 할 것이다. 옳다.
  - Optimal stop problems이 떠올랐다.
  - 10명이 있을때 10명을 다 가지 않는 방법이다.
  - 근데 문제가 있다. Monsters에 쌓이는 순서가 무작위가 아니다.
  - 머리에 담고만 있다. 
- 우선순위를 두고 작업했다.
- 컨트롤러 제어 우선, 몬스터 타격 차선, 자원 채집이 그 다음 등.
- 정렬에서 콜리전이 생각보다 유용하게 쓰였다.
